Этот документ описывает процедуру инициализации библиотеки плагинов и каждого плагина в библиотеке.

Инициализация библиотеки плагинов начинается сразу после того, как они были скачаны с сервера.
## Процедура инициализации такова ##

  1. Загружается библиотека мастер-плагина вызовом LoadLibraryA из по адресу: 

&lt;UO&gt;

\UOExt\Master.plg
  1. Ведется поиск через GetProcAddress процедур [DllInit](DllInit.md) и [DllInitDone](DllInitDone.md). Функция [DllInitDone](DllInitDone.md) может не присутствовать в библиотеке, если ей не надо освобождать память, захваченную в процедуре DllInit.
  1. Вызывается процедура [DllInit](DllInit.md) и ведется разбор полученной информации.
  1. Инициализируется первый плагин в библиотеке путем вызова [PluginProcedure](PluginProcedure.md) с параметром PE\_MASTERINIT. Он считается мастер-плагином. (Первый в данных, полученных из DllInit)
  1. Мастер-плагин вызывает API функцию LoadPluginsLibrary 0 или более раз, формируя список бибилотек.
  1. Для каждой бибилиотеки, которую загрузил мастер-плагин вызывается DllInit/DllInitDone и считываются списки плагинов.
  1. Формируется список плагинов и начинается их инициализация. Для каждого плагины вызывается [PluginProcedure](PluginProcedure.md), полученная из DllInit с параметром PE\_INIT. Мастер-плагин так-же инициализируется.
  1. После инициализации всех плагинов управление передается в точку входа настоящего ехе.
  1. Как только происходит попытка подключения к удаленному серверу, стартует отдельный поток прокси-сервера и плагинам через PluginProcedure передается событие PE\_PROXYSTART. Для клиента процедура connect все еще не закончилась, это гарантирует то, что ни один пакет не был передан с клиента на сервер и обратно.
  1. В это время клиент подключается к Login-серверу UO. Он авторизуется и получает список игровых серверов. Обычно в фри-шардах там присутствуеи только один игровой сервер (в случае с шардами, которые гонят отдельный траффик в определенную есть и имеют плохих администраторов, тут может быть 2+ геим-сервера).
  1. Как только клиент пытается подключиться к игровому серверу, в зависимости от реализации самого клиента, может наступить (и обычно наступает) событие PE\_PROXYEND, а потом сразу-же PE\_PROXYSTART. В дальнейшем в событии PE\_PROXYSTART планируется указывать тип сервера, к которому идет подключение.
  1. Клиент работает в штатном режиме.
## Примечания ##
Фактически, событие PE\_INIT вызывается в основном потоке приложения и до старта самого приложения. В обработчике этого события можно заниматься патчингом клиента, ставить хуки на процедуры, запускать дополнительные потоки и т.д.

Событие PE\_PROXYSTART вызывается когда клиент уже работает и пользователь ввел логин, пароль и нажал на кнопку "Далее". Все управляющие структуры и потоки UOExt на этот момент уже создались и работают, хотя поток прокси-сервера еще не перешел в стандартный цикл приема-отсылки сообщений. На этом этапе уже можно отсылать сообщения серверу, но это делать крайне нежелательно из-за архитектуры протокола UO и реализации в различных серверах.

Я рекомендую всю "инициализационную" часть делать или внутри события PE\_INIT, или после отсылки первого пакета на игровой сервер (не путать с Login-сервером). Во втором случае вам надо на PE\_PROXYSTART поставить обработчик на пакет 0x91 (Game Server Login) и в нем уже регистрировать новые обработчики и т.д.

## Чего делать нельзя ##
Ни в коем случае нельзя делать что-либо в DllMain на этапе загрузки dll. Дело в том, что в DllMain есть ряд ограничений, описанных в MSDN, и для обхода этих ограничений и было придумано событие PE\_INIT(в том числе).

Во время обработки сообщения PE\_INIT нельзя регистрировать обработчики пакетов тех или иных пакетов. Ошибку это не вызовет, но ссылки на обработчики пакетов все-равно будут обнулены на PE\_PROXYSTART.
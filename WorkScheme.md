Этот документ описывает основные моменты логики работы UOExt.

Вся работа делится на 3 части:
  1. Заражение и загрузка UOExt.dll перед тем, как будет запущен основной ехе
  1. Инициализация UOExt и запуск основного приложения
  1. Работа прокси-сервера

Подробнее о каждой из частей:

## Заражение и загрузка ##
Как написано в документе по [установке](Installation.md), сначала надо "заразить" выполняемый файл UO. Это делается путем выполнения команды
`UOExt.cc.exe /INFECT <Executable>`

Где _Executable_ - название ехе.

Заражение выполняется путем внедрения новой секции кода и помещением туда исполняемого кода, который загружает UOExt.dll, а потом передает управление в точку входа приложения.

Это самый простой метод заражения, который уже довольно давно не используется при написании вирусов, но все-равно некоторые антивирусы могут начинать ругаться на неизвестный вирус.

## Инициализация ##
Самая большая и сложная часть.

Инициализация начинается с того, что создаётся консоль(если UOExt собрано с флагами DEBUG или DEBUGWINDOW) и окно представления информации(если есть бибилиотека UOExt.gui.dll).

После инициализации и выполнения всех необходимых действий загружается клиент UO. UOExt перехватывает попытку подключения к серверу и, в случае если клиент был запущен с параметрами IP:Port (например: client.exe 127.0.0.1:2593), то соединение устанавливается именно к этому IP и порту игнорируя настройки клиента и Razor'а.

## Прокси-сервер ##
Для начала я объясню зачем вообще нужен прокси-сервер...

Существует 2 подхода к реализации аналога UOExt:
  * Перехват send и recv и работа во время их вызова
  * Создание прокси-сервера

Перехват send и recv неудобен по нескольким причинам:
  * Вы не можете послать пакет "прямо сейчас", вам в любом случае надо ждать когда будет выполнен send или recv, а в некоторых игровых моментах это может занимать секунды.
  * Долгая обработка того или иного пакета будет видна клиенту как "тормоза" клиента.

Вариант с прокси-сервером лишен этих недостатков:
  * Пакет как клиенту так и серверу можно послать в любой момент.
  * Процесс работы клиента (2д) сейчас устроен так, что в случае неответа сервера, клиент может "бежать" еще 3-4 клетки, а это значит что у вас есть где-то секунда реального времени для обработки любого пакета (хотя и долгие вычисления желательно выводить в отдельные потоки). Фактически "тормоз" заменяется на "лаг" сети, но это менее неприятно.

### Теперь о том, как работает прокси-сервер ###

Прокси-сервер выполняется в отдельном потоке и хоть и имеет общее адресное пространство с приложением, но не мешает ему. Таким образом, с одной стороны, вы можете модифицировать клиент, с другой - выполнять сложные расчеты по событию, не мешая ему. Это расширяет возможности модифицирования логики клиента до, практически, безграничных возможностей (во время подготовки первой версии и релиза промежуточных сборок были заявлены плагины, которые меняют логин окно клиента, заменяя его своим, пропускают процесс создания персонажа, реализуют свой звуковой движок и т.д. Вполне возможно, что на момент прочтения, эти плагины уже доступы для скачивания).

Итак, прокси-сервер слушает клиент и сервер (если это необходимо плагинам) и, как только данные пришли, пытается декодировать и расшифровать их. После этого он вызывает обработчики тех или иных пакетов и опять кодирует и шифрует пакеты, отправляя их дальше - серверу или клиенту.
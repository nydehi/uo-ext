#sidebar TableOfContents
Этот документ описывает процедуру инициализации библиотеки плагинов и каждого плагина в библиотеке.

Инициализация библиотеки плагинов начинается сразу после того, как они были скачаны с сервера.
==Процедура инициализации такова==

  # Загружается библиотека мастер-плагина вызовом LoadLibraryA из по адресу: <UO>\UOExt\Master.plg
  # Ведется поиск через !GetProcAddress процедур [DllInit] и [DllInitDone]. Функция [DllInitDone] может не присутствовать в библиотеке, если ей не надо освобождать память, захваченную в процедуре DllInit.
  # Вызывается процедура [DllInit] и ведется разбор полученной информации.
  # Инициализируется первый плагин в библиотеке путем вызова [PluginProcedure] с параметром PE_MASTERINIT. Он считается мастер-плагином. (Первый в данных, полученных из DllInit)
  # Мастер-плагин вызывает API функцию LoadPluginsLibrary 0 или более раз, формируя список бибилотек.
  # Для каждой бибилиотеки, которую загрузил мастер-плагин вызывается DllInit/DllInitDone и считываются списки плагинов.
  # Формируется список плагинов и начинается их инициализация. Для каждого плагины вызывается [PluginProcedure], полученная из DllInit с параметром PE_INIT. Мастер-плагин так-же инициализируется.
  # После инициализации всех плагинов управление передается в точку входа настоящего ехе.
  # Как только происходит попытка подключения к удаленному серверу, стартует отдельный поток прокси-сервера и плагинам через PluginProcedure передается событие PE_PROXYSTART. Для клиента процедура connect все еще не закончилась, это гарантирует то, что ни один пакет не был передан с клиента на сервер и обратно.
  # В это время клиент подключается к Login-серверу UO. Он авторизуется и получает список игровых серверов. Обычно в фри-шардах там присутствуеи только один игровой сервер (в случае с шардами, которые гонят отдельный траффик в определенную есть и имеют плохих администраторов, тут может быть 2+ геим-сервера).
  # Как только клиент пытается подключиться к игровому серверу, в зависимости от реализации самого клиента, может наступить (и обычно наступает) событие PE_PROXYEND, а потом сразу-же PE_PROXYSTART. В дальнейшем в событии PE_PROXYSTART планируется указывать тип сервера, к которому идет подключение.
  # Клиент работает в штатном режиме.
==Примечания==
Фактически, событие PE_INIT вызывается в основном потоке приложения и до старта самого приложения. В обработчике этого события можно заниматься патчингом клиента, ставить хуки на процедуры, запускать дополнительные потоки и т.д.

Событие PE_PROXYSTART вызывается когда клиент уже работает и пользователь ввел логин, пароль и нажал на кнопку "Далее". Все управляющие структуры и потоки UOExt на этот момент уже создались и работают, хотя поток прокси-сервера еще не перешел в стандартный цикл приема-отсылки сообщений. На этом этапе уже можно отсылать сообщения серверу, но это делать крайне нежелательно из-за архитектуры протокола UO и реализации в различных серверах.

Я рекомендую всю "инициализационную" часть делать или внутри события PE_INIT, или после отсылки первого пакета на игровой сервер (не путать с Login-сервером). Во втором случае вам надо на PE_PROXYSTART поставить обработчик на пакет 0x91 (Game Server Login) и в нем уже регистрировать новые обработчики и т.д.

==Чего делать нельзя==
Ни в коем случае нельзя делать что-либо в DllMain на этапе загрузки dll. Дело в том, что в DllMain есть ряд ограничений, описанных в MSDN, и для обхода этих ограничений и было придумано событие PE_INIT(в том числе).

Во время обработки сообщения PE_INIT нельзя регистрировать обработчики пакетов тех или иных пакетов. Ошибку это не вызовет, но ссылки на обработчики пакетов все-равно будут обнулены на PE_PROXYSTART.